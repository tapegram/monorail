-- {{pascalCase typeName}} JSON Mappers
-- Generated by Monorail (plop)

-- =============================================================================
-- JSON ENCODER
-- =============================================================================

{{pascalCase typeName}}.encoder : {{pascalCase typeName}} -> Json
{{pascalCase typeName}}.encoder value =
  object.empty
{{#each fields}}
{{#if (eq type "Text")}}
    |> object.addText "{{name}}" value.{{name}}
{{else if (eq type "Nat")}}
    |> object.addNat "{{name}}" value.{{name}}
{{else if (eq type "Int")}}
    |> object.addInt "{{name}}" value.{{name}}
{{else if (eq type "Float")}}
    |> object.addFloat "{{name}}" value.{{name}}
{{else if (eq type "Boolean")}}
    |> object.addBoolean "{{name}}" value.{{name}}
{{else if (startsWith type "Optional ")}}
    |> (match value.{{name}} with
          Some v -> object.addText "{{name}}" v
          None -> identity)
{{else if (startsWith type "[")}}
    |> object.addArray "{{name}}" (List.map Json.String value.{{name}})
{{else}}
    |> object.addJson "{{name}}" ({{type}}.encoder value.{{name}})
{{/if}}
{{/each}}

-- =============================================================================
-- JSON DECODER
-- =============================================================================

{{pascalCase typeName}}.decoder : '{Decoder} {{pascalCase typeName}}
{{pascalCase typeName}}.decoder = do
  use object at! atOptional
{{#each fields}}
{{#if (eq type "Text")}}
  {{name}} = at! "{{name}}" Decoder.text
{{else if (eq type "Nat")}}
  {{name}} = at! "{{name}}" Decoder.nat
{{else if (eq type "Int")}}
  {{name}} = at! "{{name}}" Decoder.int
{{else if (eq type "Float")}}
  {{name}} = at! "{{name}}" Decoder.float
{{else if (eq type "Boolean")}}
  {{name}} = at! "{{name}}" Decoder.boolean
{{else if (startsWith type "Optional ")}}
  {{name}} = atOptional "{{name}}" Decoder.text
{{else if (startsWith type "[")}}
  {{name}} = at! "{{name}}" (Decoder.array Decoder.text)
{{else}}
  {{name}} = at! "{{name}}" {{type}}.decoder
{{/if}}
{{/each}}
  { {{#each fields}}{{name}}{{#unless @last}}, {{/unless}}{{/each}} }

-- =============================================================================
-- CONVENIENCE HELPERS
-- =============================================================================

{{pascalCase typeName}}.encode : {{pascalCase typeName}} -> Text
{{pascalCase typeName}}.encode value = Json.toText ({{pascalCase typeName}}.encoder value)

{{pascalCase typeName}}.decode : Text ->{Exception} {{pascalCase typeName}}
{{pascalCase typeName}}.decode txt =
  match Json.tryFromText txt with
    Right json ->
      match Decoder.run {{pascalCase typeName}}.decoder json with
        Right value -> value
        Left err -> Exception.raise (failure "Failed to decode {{pascalCase typeName}}" err)
    Left parseErr ->
      Exception.raise (failure "Failed to parse JSON" parseErr)

-- =============================================================================
-- TESTS
-- =============================================================================

test> {{pascalCase typeName}}.tests.jsonRoundTrip = test.verify do
  original =
    { {{#each fields}}{{name}} = {{#if (eq type "Text")}}"test-{{name}}"{{else if (eq type "Nat")}}42{{else if (eq type "Int")}}+42{{else if (eq type "Float")}}3.14{{else if (eq type "Boolean")}}true{{else if (startsWith type "Optional ")}}Some "test"{{else if (startsWith type "[")}}["a", "b"]{{else}}todo "provide test value"{{/if}}{{#unless @last}}
    , {{/unless}}{{/each}}
    }
  encoded = {{pascalCase typeName}}.encode original
  decoded = {{pascalCase typeName}}.decode encoded
  ensureEqual original decoded
