-- {{pascalCase entityName}} CRUD Module
-- Generated by Monorail (plop)
--
-- REQUIRED LIBRARIES:
--   @unison/cloud       (Database, OrderedTable, Remote)
--   @unison/routes      (Route ability, hx_* attributes)
--   @unison/json        (JSON encoding/decoding - REQUIRED for storage)
--   @tapegram/html      (Html type, HTML elements)
--   @tapegram/htmx      (hx_post, hx_delete, hx_target, hx_swap)
--
-- NOTE: This module stores entities as JSON for schema evolution.
-- JSON mappers ({{pascalCase entityName}}.encode/decode) are REQUIRED.
-- Use --includeJson true or generate separately with: plop -- json-mappers

-- =============================================================================
-- DOMAIN TYPE
-- =============================================================================

type app.domain.{{pascalCase entityName}} =
  { id : Text
{{#each fields}}
  , {{name}} : {{type}}
{{/each}}
  }

-- =============================================================================
-- REPOSITORY PORT (ABILITY)
-- =============================================================================

ability app.ports.{{pascalCase entityName}}Repository where
  get     : Text ->{{openBrace}}app.ports.{{pascalCase entityName}}Repository} (Optional app.domain.{{pascalCase entityName}})
  listAll : '{{openBrace}}app.ports.{{pascalCase entityName}}Repository} [app.domain.{{pascalCase entityName}}]
  upsert  : app.domain.{{pascalCase entityName}} ->{{openBrace}}app.ports.{{pascalCase entityName}}Repository} ()
  delete  : Text ->{{openBrace}}app.ports.{{pascalCase entityName}}Repository} ()
{{#each customOperations}}
  {{name}} : {{#if (eq inputType "()")}}'{{openBrace}}app.ports.{{pascalCase ../entityName}}Repository} {{outputType}}{{else}}{{inputType}} ->{{openBrace}}app.ports.{{pascalCase ../entityName}}Repository} {{outputType}}{{/if}}
{{/each}}

-- =============================================================================
-- REPOSITORY ADAPTER (HANDLER)
-- =============================================================================

-- NOTE: Stores entities as JSON text for schema evolution compatibility.
-- If you change the {{pascalCase entityName}} type, old data will still be readable
-- as long as you handle missing fields in the decoder.

app.adapters.storage.{{pascalCase entityName}}Repository.run :
  Database ->
  '{{openBrace}}g, app.ports.{{pascalCase entityName}}Repository, Exception} a ->
  {{openBrace}}g, Remote, Exception} a
app.adapters.storage.{{pascalCase entityName}}Repository.run db computation =
  -- Store as JSON text for schema evolution
  table : OrderedTable Text Text
  table = OrderedTable.named db "{{pluralize (lowercase entityName)}}" Universal.ordering

  -- NOTE: get' and listAll' need Exception because decode can fail
  get' : Text ->{{openBrace}}g, Remote, Exception} (Optional app.domain.{{pascalCase entityName}})
  get' entityId =
    match OrderedTable.tryRead table entityId with
      Optional.None -> Optional.None
      Optional.Some json -> Optional.Some (app.domain.{{pascalCase entityName}}.decode json)

  listAll' : '{{openBrace}}g, Remote, Exception} [app.domain.{{pascalCase entityName}}]
  listAll' = do
    OrderedTable.toStream table
      |> Stream.map (kv -> app.domain.{{pascalCase entityName}}.decode (at2 kv))
      |> Stream.toList

  upsert' : app.domain.{{pascalCase entityName}} ->{{openBrace}}g, Remote} ()
  upsert' entity =
    json = app.domain.{{pascalCase entityName}}.encode entity
    OrderedTable.write table (app.domain.{{pascalCase entityName}}.id entity) json

  delete' : Text ->{{openBrace}}g, Remote} ()
  delete' entityId = OrderedTable.delete table entityId
{{#each customOperations}}

  {{name}}' : {{#if (eq inputType "()")}}'{{openBrace}}g, Remote} {{outputType}}{{else}}{{inputType}} ->{{openBrace}}g, Remote} {{outputType}}{{/if}}
  {{name}}' {{#unless (eq inputType "()")}}opInput {{/unless}}= todo "Implement {{name}}"
{{/each}}

  -- NOTE: go needs Exception because get' and listAll' need it
  go : '{{openBrace}}g, app.ports.{{pascalCase entityName}}Repository, Exception} a -> {{openBrace}}g, Remote, Exception} a
  go p =
    handle p()
    with cases
      {{openBrace}} app.ports.{{pascalCase entityName}}Repository.get entityId -> resume } ->
        result = get' entityId
        go do resume result
      {{openBrace}} app.ports.{{pascalCase entityName}}Repository.listAll _ -> resume } ->
        result = listAll'()
        go do resume result
      {{openBrace}} app.ports.{{pascalCase entityName}}Repository.upsert entity -> resume } ->
        result = upsert' entity
        go do resume result
      {{openBrace}} app.ports.{{pascalCase entityName}}Repository.delete entityId -> resume } ->
        result = delete' entityId
        go do resume result
{{#each customOperations}}
      {{openBrace}} app.ports.{{pascalCase ../entityName}}Repository.{{name}} {{#unless (eq inputType "()")}}opInput {{/unless}}-> resume } ->
        result = {{name}}' {{#unless (eq inputType "()")}}opInput{{/unless}}{{#if (eq inputType "()")}}(){{/if}}
        go do resume result
{{/each}}
      {{openBrace}} a } -> a

  go computation

-- =============================================================================
-- SERVICE
-- =============================================================================

type app.services.{{pascalCase entityName}}Service.CreateInput =
  { {{#each fields}}{{name}} : {{type}}{{#unless @last}}
  , {{/unless}}{{/each}}
  }

type app.services.{{pascalCase entityName}}Service.UpdateInput =
  { {{#each fields}}{{name}} : {{type}}{{#unless @last}}
  , {{/unless}}{{/each}}
  }

app.services.{{pascalCase entityName}}Service.create :
  app.services.{{pascalCase entityName}}Service.CreateInput ->
  {{openBrace}}app.ports.{{pascalCase entityName}}Repository, Random} app.domain.{{pascalCase entityName}}
app.services.{{pascalCase entityName}}Service.create createInput =
  newId = newv4() |> Uuid.toText
  entity = app.domain.{{pascalCase entityName}} newId {{#each fields}}(app.services.{{pascalCase ../entityName}}Service.CreateInput.{{name}} createInput){{#unless @last}} {{/unless}}{{/each}}
  app.ports.{{pascalCase entityName}}Repository.upsert entity
  entity

app.services.{{pascalCase entityName}}Service.get :
  Text ->
  {{openBrace}}app.ports.{{pascalCase entityName}}Repository} (Optional app.domain.{{pascalCase entityName}})
app.services.{{pascalCase entityName}}Service.get entityId =
  app.ports.{{pascalCase entityName}}Repository.get entityId

app.services.{{pascalCase entityName}}Service.listAll :
  '{{openBrace}}app.ports.{{pascalCase entityName}}Repository} [app.domain.{{pascalCase entityName}}]
app.services.{{pascalCase entityName}}Service.listAll =
  app.ports.{{pascalCase entityName}}Repository.listAll

app.services.{{pascalCase entityName}}Service.update :
  Text ->
  app.services.{{pascalCase entityName}}Service.UpdateInput ->
  {{openBrace}}app.ports.{{pascalCase entityName}}Repository, Exception} app.domain.{{pascalCase entityName}}
app.services.{{pascalCase entityName}}Service.update entityId updateInput =
  use Optional None Some
  match app.ports.{{pascalCase entityName}}Repository.get entityId with
    Some existing ->
      updated = app.domain.{{pascalCase entityName}} (app.domain.{{pascalCase entityName}}.id existing) {{#each fields}}(app.services.{{pascalCase ../entityName}}Service.UpdateInput.{{name}} updateInput){{#unless @last}} {{/unless}}{{/each}}
      app.ports.{{pascalCase entityName}}Repository.upsert updated
      updated
    None ->
      Exception.raise (failure "{{pascalCase entityName}} not found" entityId)

app.services.{{pascalCase entityName}}Service.delete :
  Text ->
  {{openBrace}}app.ports.{{pascalCase entityName}}Repository, Exception} ()
app.services.{{pascalCase entityName}}Service.delete entityId =
  use Optional None Some
  match app.ports.{{pascalCase entityName}}Repository.get entityId with
    Some _ -> app.ports.{{pascalCase entityName}}Repository.delete entityId
    None -> Exception.raise (failure "{{pascalCase entityName}} not found" entityId)
{{#each customOperations}}

app.services.{{pascalCase ../entityName}}Service.{{name}} :
  {{#if (eq inputType "()")}}'{{openBrace}}app.ports.{{pascalCase ../entityName}}Repository} {{outputType}}{{else}}{{inputType}} ->{{openBrace}}app.ports.{{pascalCase ../entityName}}Repository} {{outputType}}{{/if}}
app.services.{{pascalCase ../entityName}}Service.{{name}} {{#unless (eq inputType "()")}}serviceInput {{/unless}}=
  app.ports.{{pascalCase ../entityName}}Repository.{{name}} {{#unless (eq inputType "()")}}serviceInput{{/unless}}
{{/each}}

-- =============================================================================
-- ROUTES
-- =============================================================================

app.routes.{{pluralize (camelCase entityName)}} :
  '{{openBrace}}Route, Log, Exception, app.ports.{{pascalCase entityName}}Repository, Random} ()
app.routes.{{pluralize (camelCase entityName)}} =
  use Route <|>
  use Parser s

  -- GET /{{pluralize (lowercase entityName)}} - List all
  indexRoute = do
    noCapture GET (s "{{pluralize (lowercase entityName)}}")
    items = app.services.{{pascalCase entityName}}Service.listAll ()
    html = app.pages.{{pluralize (camelCase entityName)}}.index items ()
    ok.html ({{htmlLib}}.toText html)

  -- POST /{{pluralize (lowercase entityName)}} - Create new
  createRoute = do
    noCapture POST (s "{{pluralize (lowercase entityName)}}")
    formData = getFormData()
    createInput = app.services.{{pascalCase entityName}}Service.CreateInput {{#each fields}}({{#if (eq type "Text")}}form.getOnly! "{{name}}" formData{{else if (eq type "Nat")}}Nat.fromText (form.getOnly! "{{name}}" formData) |> Optional.getOrBug "Invalid {{name}}"{{else if (eq type "Int")}}Int.fromText (form.getOnly! "{{name}}" formData) |> Optional.getOrBug "Invalid {{name}}"{{else if (eq type "Float")}}Float.fromText (form.getOnly! "{{name}}" formData) |> Optional.getOrBug "Invalid {{name}}"{{else if (eq type "Boolean")}}(form.getOnly! "{{name}}" formData == "true"){{else}}form.getOnly! "{{name}}" formData{{/if}}){{#unless @last}} {{/unless}}{{/each}}
    created = app.services.{{pascalCase entityName}}Service.create createInput
    html = app.pages.{{pluralize (camelCase entityName)}}.item created ()
    ok.html ({{htmlLib}}.toText html)

  -- GET /{{pluralize (lowercase entityName)}}/:id - Get one
  showRoute = do
    entityId = route GET (s "{{pluralize (lowercase entityName)}}" Parser./ Parser.text)
    use Optional None Some
    match app.services.{{pascalCase entityName}}Service.get entityId with
      Some entity ->
        html = app.pages.{{pluralize (camelCase entityName)}}.show entity ()
        ok.html ({{htmlLib}}.toText html)
      None ->
        notFound.text ("{{pascalCase entityName}} not found: " Text.++ entityId)

  -- DELETE /{{pluralize (lowercase entityName)}}/:id - Delete
  destroyRoute = do
    entityId = route DELETE (s "{{pluralize (lowercase entityName)}}" Parser./ Parser.text)
    app.services.{{pascalCase entityName}}Service.delete entityId
    ok.text ""

  -- Order matters: more specific routes first
  destroyRoute <|> showRoute <|> createRoute <|> indexRoute

-- =============================================================================
-- PAGES
-- =============================================================================

app.pages.{{pluralize (camelCase entityName)}}.index :
  [app.domain.{{pascalCase entityName}}] ->
  '{{openBrace}}Route} Html
app.pages.{{pluralize (camelCase entityName)}}.index items = do
  use {{htmlLib}} article button div form h1 li text ul

  createUrl = baseUrl() Path./ "{{pluralize (lowercase entityName)}}" |> Path.toText

  article []
    [ h1 [] [text "{{pascalCase entityName}}s"]
    , form
        [ hx_post createUrl
        , hx_target "#{{lowercase entityName}}-list"
        , hx_swap AdjacentHtml.BeforeEnd Optional.None
        ]
        [ {{#each fields}}input [name "{{name}}", placeholder "{{name}}"]
        , {{/each}}button [type_ "submit"] [text "Add {{pascalCase entityName}}"]
        ]
    , ul [id "{{lowercase entityName}}-list"]
        (List.map (entity -> app.pages.{{pluralize (camelCase entityName)}}.item entity ()) items)
    ]

app.pages.{{pluralize (camelCase entityName)}}.item :
  app.domain.{{pascalCase entityName}} ->
  '{{openBrace}}Route} Html
app.pages.{{pluralize (camelCase entityName)}}.item entity = do
  use {{htmlLib}} button li span text

  deleteUrl = baseUrl() Path./ "{{pluralize (lowercase entityName)}}" Path./ (app.domain.{{pascalCase entityName}}.id entity) |> Path.toText

  li []
    [ span [] [text (app.domain.{{pascalCase entityName}}.{{#if fields}}{{fields.[0].name}}{{else}}id{{/if}} entity)]
    , button
        [ hx_delete deleteUrl
        , hx_target "closest li"
        , hx_swap AdjacentHtml.OuterHtml Optional.None
        ]
        [text "Delete"]
    ]

app.pages.{{pluralize (camelCase entityName)}}.show :
  app.domain.{{pascalCase entityName}} ->
  '{{openBrace}}Route} Html
app.pages.{{pluralize (camelCase entityName)}}.show entity = do
  use {{htmlLib}} article dd dl dt h1 text

  article []
    [ h1 [] [text "{{pascalCase entityName}} Details"]
    , dl []
        [ dt [] [text "ID"]
        , dd [] [text (app.domain.{{pascalCase entityName}}.id entity)]
{{#each fields}}
        , dt [] [text "{{name}}"]
        , dd [] [text ({{#if (eq type "Text")}}app.domain.{{pascalCase ../entityName}}.{{name}} entity{{else}}Debug.evalToText (app.domain.{{pascalCase ../entityName}}.{{name}} entity){{/if}})]
{{/each}}
        ]
    ]
