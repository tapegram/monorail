-- {{pascalCase entityName}} CRUD Module
-- Generated by Monorail (plop)

-- =============================================================================
-- DOMAIN TYPE
-- =============================================================================

type {{pascalCase entityName}} =
  { id : Text
{{#each fields}}
  , {{name}} : {{type}}
{{/each}}
  }

-- =============================================================================
-- REPOSITORY PORT (ABILITY)
-- =============================================================================

ability {{pascalCase entityName}}Repository where
  get     : Text ->{{"{"}}{{pascalCase entityName}}Repository} (Optional {{pascalCase entityName}})
  listAll : '{{"{"}}{{pascalCase entityName}}Repository} [{{pascalCase entityName}}]
  upsert  : {{pascalCase entityName}} ->{{"{"}}{{pascalCase entityName}}Repository} ()
  delete  : Text ->{{"{"}}{{pascalCase entityName}}Repository} ()

-- =============================================================================
-- REPOSITORY ADAPTER (HANDLER)
-- =============================================================================

storage.{{pascalCase entityName}}Repository.run :
  Database ->
  '{g, {{pascalCase entityName}}Repository} a ->
  {g, Remote} a
storage.{{pascalCase entityName}}Repository.run db p =
  table : OrderedTable Text {{pascalCase entityName}}
  table = OrderedTable.named db "{{pluralize (lowercase entityName)}}" Universal.ordering

  get' : Text ->{g, Remote} (Optional {{pascalCase entityName}})
  get' id = OrderedTable.tryRead table id

  listAll' : '{g, Remote} [{{pascalCase entityName}}]
  listAll' =
    do OrderedTable.toStream table
       |> Stream.map at2
       |> Stream.toList

  upsert' : {{pascalCase entityName}} ->{g, Remote} ()
  upsert' e = OrderedTable.write table e.id e

  delete' : Text ->{g, Remote} ()
  delete' id = OrderedTable.delete table id

  go : '{g, {{pascalCase entityName}}Repository} a -> {g, Remote} a
  go p = handle !p with cases
    {get id -> resume}     -> go '(resume (get' id))
    {listAll _ -> resume}  -> go '(resume (listAll' ()))
    {upsert e -> resume}   -> go '(resume (upsert' e))
    {delete id -> resume}  -> go '(resume (delete' id))
    {k} -> k

  go p

-- =============================================================================
-- FAKE REPOSITORY (FOR TESTING)
-- =============================================================================

{{pascalCase entityName}}Repository.fake :
  Ref [{{pascalCase entityName}}] ->
  '{g, {{pascalCase entityName}}Repository} a ->
  {g} a
{{pascalCase entityName}}Repository.fake storage p =
  go : '{g, {{pascalCase entityName}}Repository} a -> {g} a
  go p = handle !p with cases
    {get id -> resume} ->
      items = Ref.read storage
      result = List.find (item -> item.id == id) items
      go '(resume result)

    {listAll _ -> resume} ->
      items = Ref.read storage
      go '(resume items)

    {upsert item -> resume} ->
      items = Ref.read storage
      filtered = List.filter (i -> i.id != item.id) items
      Ref.write storage (item +: filtered)
      go '(resume ())

    {delete id -> resume} ->
      items = Ref.read storage
      filtered = List.filter (i -> i.id != id) items
      Ref.write storage filtered
      go '(resume ())

    {k} -> k

  go p

-- =============================================================================
-- SERVICE
-- =============================================================================

type {{pascalCase entityName}}Service.CreateInput =
  { {{#each fields}}{{name}} : {{type}}{{#unless @last}}
  , {{/unless}}{{/each}}
  }

type {{pascalCase entityName}}Service.UpdateInput =
  { {{#each fields}}{{name}} : {{type}}{{#unless @last}}
  , {{/unless}}{{/each}}
  }

{{pascalCase entityName}}Service.create :
  {{pascalCase entityName}}Service.CreateInput ->
  {{"{"}}{{pascalCase entityName}}Repository, Random} {{pascalCase entityName}}
{{pascalCase entityName}}Service.create input =
  id = Uuid.new () |> Uuid.toText
  entity = { id{{#each fields}}, {{name}} = input.{{name}}{{/each}} }
  {{pascalCase entityName}}Repository.upsert entity
  entity

{{pascalCase entityName}}Service.get :
  Text ->
  {{"{"}}{{pascalCase entityName}}Repository} (Optional {{pascalCase entityName}})
{{pascalCase entityName}}Service.get id =
  {{pascalCase entityName}}Repository.get id

{{pascalCase entityName}}Service.listAll :
  '{{"{"}}{{pascalCase entityName}}Repository} [{{pascalCase entityName}}]
{{pascalCase entityName}}Service.listAll =
  {{pascalCase entityName}}Repository.listAll

{{pascalCase entityName}}Service.update :
  Text ->
  {{pascalCase entityName}}Service.UpdateInput ->
  {{"{"}}{{pascalCase entityName}}Repository, Exception} {{pascalCase entityName}}
{{pascalCase entityName}}Service.update id input =
  use Optional None Some
  match {{pascalCase entityName}}Repository.get id with
    Some existing ->
      updated = { existing with {{#each fields}}{{name}} = input.{{name}}{{#unless @last}}, {{/unless}}{{/each}} }
      {{pascalCase entityName}}Repository.upsert updated
      updated
    None ->
      Exception.raise (failure "{{pascalCase entityName}} not found" id)

{{pascalCase entityName}}Service.delete :
  Text ->
  {{"{"}}{{pascalCase entityName}}Repository, Exception} ()
{{pascalCase entityName}}Service.delete id =
  use Optional None Some
  match {{pascalCase entityName}}Repository.get id with
    Some _ -> {{pascalCase entityName}}Repository.delete id
    None -> Exception.raise (failure "{{pascalCase entityName}} not found" id)

-- =============================================================================
-- ROUTES
-- =============================================================================

app.routes.{{pluralize (camelCase entityName)}} :
  '{Route, Log, Exception, {{pascalCase entityName}}Repository, Random} ()
app.routes.{{pluralize (camelCase entityName)}} =
  use Route <|>
  use Parser / s

  -- GET /{{pluralize (lowercase entityName)}} - List all
  index = do
    noCapture GET (s "{{pluralize (lowercase entityName)}}")
    items = {{pascalCase entityName}}Service.listAll ()
    html = app.pages.{{pluralize (camelCase entityName)}}.index items ()
    ok.html ({{htmlLib}}.toText html)
  index

  -- POST /{{pluralize (lowercase entityName)}} - Create new
  create = do
    noCapture POST (s "{{pluralize (lowercase entityName)}}")
    formData = getFormData()
    input =
      { {{#each fields}}{{name}} = form.getOnly! "{{name}}" formData{{#unless @last}}
      , {{/unless}}{{/each}}
      }
    item = {{pascalCase entityName}}Service.create input
    html = app.pages.{{pluralize (camelCase entityName)}}.item item ()
    ok.html ({{htmlLib}}.toText html)
  create

  -- GET /{{pluralize (lowercase entityName)}}/:id - Get one
  show = do
    id = route GET (s "{{pluralize (lowercase entityName)}}" / Parser.text)
    use Optional None Some
    match {{pascalCase entityName}}Service.get id with
      Some item ->
        html = app.pages.{{pluralize (camelCase entityName)}}.show item ()
        ok.html ({{htmlLib}}.toText html)
      None ->
        notFound.text ("{{pascalCase entityName}} not found: " Text.++ id)
  show

  -- DELETE /{{pluralize (lowercase entityName)}}/:id - Delete
  destroy = do
    id = route DELETE (s "{{pluralize (lowercase entityName)}}" / Parser.text)
    {{pascalCase entityName}}Service.delete id
    ok.text ""
  destroy

  -- Order matters: more specific routes first
  destroy <|> show <|> create <|> index

-- =============================================================================
-- PAGES
-- =============================================================================

app.pages.{{pluralize (camelCase entityName)}}.index :
  [{{pascalCase entityName}}] ->
  '{Route} Html
app.pages.{{pluralize (camelCase entityName)}}.index items = do
  use {{htmlLib}} article button div form h1 input li text ul
  use Path /

  createUrl = baseUrl() / "{{pluralize (lowercase entityName)}}" |> Path.toText

  article []
    [ h1 [] [text "{{pascalCase entityName}}s"]
    , form
        [ hx_post createUrl
        , hx_target "#{{lowercase entityName}}-list"
        , hx_swap "beforeend"
        ]
        [ {{#each fields}}input [name "{{name}}", placeholder "{{name}}"] []
        , {{/each}}button [type' "submit"] [text "Add {{pascalCase entityName}}"]
        ]
    , ul [id "{{lowercase entityName}}-list"]
        (List.map (item -> app.pages.{{pluralize (camelCase entityName)}}.item item ()) items)
    ]

app.pages.{{pluralize (camelCase entityName)}}.item :
  {{pascalCase entityName}} ->
  '{Route} Html
app.pages.{{pluralize (camelCase entityName)}}.item item = do
  use {{htmlLib}} button li span text
  use Path /

  deleteUrl = baseUrl() / "{{pluralize (lowercase entityName)}}" / item.id |> Path.toText

  li []
    [ span [] [text item.{{#if fields}}{{fields.[0].name}}{{else}}id{{/if}}]
    , button
        [ hx_delete deleteUrl
        , hx_target "closest li"
        , hx_swap "outerHTML"
        ]
        [text "Delete"]
    ]

app.pages.{{pluralize (camelCase entityName)}}.show :
  {{pascalCase entityName}} ->
  '{Route} Html
app.pages.{{pluralize (camelCase entityName)}}.show item = do
  use {{htmlLib}} article dd dl dt h1 text
  use Path /

  article []
    [ h1 [] [text "{{pascalCase entityName}} Details"]
    , dl []
        [ dt [] [text "ID"]
        , dd [] [text item.id]
{{#each fields}}
        , dt [] [text "{{name}}"]
        , dd [] [text ({{#if (eq type "Text")}}item.{{name}}{{else}}Debug.evalToText item.{{name}}{{/if}})]
{{/each}}
        ]
    ]
