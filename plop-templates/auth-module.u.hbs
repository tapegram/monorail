-- =============================================================================
-- AUTHENTICATION MODULE
-- Generated by Monorail (plop)
--
-- REQUIRED LIBRARIES:
--   @unison/cloud       (Database, OrderedTable, Remote)
--   @unison/routes      (Route ability, cookies)
--   @unison/json        (JSON encoding/decoding)
--   @tapegram/html      (Html type, HTML elements)
--   @tapegram/htmx      (htmx attributes)
-- =============================================================================

-- =============================================================================
-- DOMAIN TYPES
-- =============================================================================

type auth.User =
  { id : Text
  , preferredName : Text
  , email : Text
  , hashedPassword : Text
  }

type auth.Session =
  { userId : Text
  , token : Text
  , expiresAt : Instant
  }

-- =============================================================================
-- SERVICE INPUT/OUTPUT TYPES
-- =============================================================================

type auth.SignupInput =
  { preferredName : Text
  , email : Text
  , password : Text
  }

type auth.LoginInput =
  { email : Text
  , password : Text
  }

type auth.SignupFailure
  = auth.SignupFailure.InvalidPassword Text
  | auth.SignupFailure.UserAlreadyExists
  | auth.SignupFailure.InvalidEmail

type auth.LoginFailure
  = auth.LoginFailure.UserNotFound
  | auth.LoginFailure.InvalidPassword

-- =============================================================================
-- JSON MAPPERS - USER
-- =============================================================================

auth.User.encoder : auth.User -> Json
auth.User.encoder user =
  use object addText
  object.empty
    |> addText "id" (auth.User.id user)
    |> addText "preferredName" (auth.User.preferredName user)
    |> addText "email" (auth.User.email user)
    |> addText "hashedPassword" (auth.User.hashedPassword user)

auth.User.decoder : '{Decoder} auth.User
auth.User.decoder = do
  use object at!
  id = at! "id" Decoder.text
  preferredName = at! "preferredName" Decoder.text
  email = at! "email" Decoder.text
  hashedPassword = at! "hashedPassword" Decoder.text
  auth.User.User id preferredName email hashedPassword

auth.User.encode : auth.User -> Text
auth.User.encode user = Json.toText (auth.User.encoder user)

auth.User.decode : Text ->{Exception} auth.User
auth.User.decode jsonText = Decoder.run auth.User.decoder jsonText

-- =============================================================================
-- JSON MAPPERS - SESSION
-- =============================================================================

auth.Session.encoder : auth.Session -> Json
auth.Session.encoder session =
  use object addText
  object.empty
    |> addText "userId" (auth.Session.userId session)
    |> addText "token" (auth.Session.token session)
    |> addText "expiresAt" (auth.Session.expiresAt session |> Instant.toText)

auth.Session.decoder : '{Decoder} auth.Session
auth.Session.decoder = do
  use object at!
  userId = at! "userId" Decoder.text
  token = at! "token" Decoder.text
  expiresAt = at! "expiresAt" Decoder.instant
  auth.Session.Session userId token expiresAt

auth.Session.encode : auth.Session -> Text
auth.Session.encode session = Json.toText (auth.Session.encoder session)

auth.Session.decode : Text ->{Exception} auth.Session
auth.Session.decode jsonText = Decoder.run auth.Session.decoder jsonText

-- =============================================================================
-- AUTH ABILITY (PORT)
-- =============================================================================

ability auth.Auth where
  getUserByEmail : Text ->{{openBrace}}auth.Auth} Optional auth.User
  getUserById : Text ->{{openBrace}}auth.Auth} Optional auth.User
  hashPassword : Text ->{{openBrace}}auth.Auth} Text
  upsertUser : auth.User ->{{openBrace}}auth.Auth} ()
  isPasswordValid : auth.User -> Text ->{{openBrace}}auth.Auth} Boolean
  createSession : auth.User -> Instant ->{{openBrace}}auth.Auth} auth.Session
  isTokenForActiveSession : Text -> Instant ->{{openBrace}}auth.Auth} Boolean
  getActiveSessionByToken : Text -> Instant ->{{openBrace}}auth.Auth} Optional auth.Session

-- =============================================================================
-- AUTH ADAPTER (HANDLER)
-- =============================================================================

auth.Auth.run :
  Database ->
  '{{openBrace}}g, auth.Auth} a ->
  {{openBrace}}g, Exception, Remote, Random} a
auth.Auth.run db computation =
  use Instant + >
  use Optional None Some
  use OrderedTable named tryRead write
  use Text ==
  use Universal ordering

  -- Tables for users (stored as JSON for schema evolution)
  usersById : OrderedTable Text Text
  usersById = named db "auth_users_by_id" ordering

  usersByEmail : OrderedTable Text Text
  usersByEmail = named db "auth_users_by_email" ordering

  -- Table for sessions (stored as JSON)
  sessions : OrderedTable Text Text
  sessions = named db "auth_sessions" ordering

  upsertUser' : auth.User ->{{openBrace}}g, Remote, Exception} ()
  upsertUser' user =
    json = auth.User.encode user
    write usersById (auth.User.id user) json
    write usersByEmail (auth.User.email user) json

  getUserById' : Text ->{{openBrace}}g, Remote, Exception} Optional auth.User
  getUserById' userId =
    match tryRead usersById userId with
      None -> None
      Some json -> Some (auth.User.decode json)

  getUserByEmail' : Text ->{{openBrace}}g, Remote, Exception} Optional auth.User
  getUserByEmail' email =
    match tryRead usersByEmail email with
      None -> None
      Some json -> Some (auth.User.decode json)

  upsertSession : auth.Session ->{{openBrace}}g, Remote, Exception} ()
  upsertSession session =
    json = auth.Session.encode session
    write sessions (auth.Session.token session) json

  getSessionByToken' : Text ->{{openBrace}}g, Remote, Exception} Optional auth.Session
  getSessionByToken' token =
    match tryRead sessions token with
      None -> None
      Some json -> Some (auth.Session.decode json)

  saltAndHashPassword : Text -> Text
  saltAndHashPassword password =
    use Text ++
    -- TODO: In production, use a proper salt from environment/secrets
    salt = "{{saltPrefix}}-auth-salt-change-me-in-production"
    crypto.hash Sha3_256 (salt ++ password) |> Bytes.toHex

  go : '{{openBrace}}g, auth.Auth} a ->{{openBrace}}g, Exception, Remote, Random} a
  go p =
    handle p()
    with cases
      {{openBrace}} auth.Auth.upsertUser user -> resume } ->
        upsertUser' user
        go do resume ()
      {{openBrace}} auth.Auth.getUserById userId -> resume } ->
        result = getUserById' userId
        go do resume result
      {{openBrace}} auth.Auth.getUserByEmail email -> resume } ->
        result = getUserByEmail' email
        go do resume result
      {{openBrace}} auth.Auth.isTokenForActiveSession token now -> resume } ->
        match getSessionByToken' token with
          None -> go do resume false
          Some session ->
            if auth.Session.expiresAt session > now then go do resume true
            else go do resume false
      {{openBrace}} auth.Auth.getActiveSessionByToken token now -> resume } ->
        match getSessionByToken' token with
          None -> go do resume None
          Some session ->
            if auth.Session.expiresAt session > now then go do resume (Some session)
            else go do resume None
      {{openBrace}} auth.Auth.createSession user now -> resume } ->
        sessionToken = newv4() |> Uuid.toText
        expiresAt = now + days +{{sessionDays}}
        session = auth.Session.Session (auth.User.id user) sessionToken expiresAt
        upsertSession session
        go do resume session
      {{openBrace}} auth.Auth.isPasswordValid user password -> resume } ->
        if auth.User.hashedPassword user == saltAndHashPassword password then
          go do resume true
        else go do resume false
      {{openBrace}} auth.Auth.hashPassword rawPassword -> resume } ->
        hashed = saltAndHashPassword rawPassword
        go do resume hashed
      {{openBrace}} a } -> a

  go computation

-- =============================================================================
-- AUTH SERVICE
-- =============================================================================

auth.AuthService.login :
  auth.LoginInput ->
  Instant ->
  {{openBrace}}auth.Auth} Either auth.LoginFailure auth.Session
auth.AuthService.login input now =
  use Optional None Some
  match auth.Auth.getUserByEmail (auth.LoginInput.email input) with
    None -> Left auth.LoginFailure.UserNotFound
    Some user ->
      if auth.Auth.isPasswordValid user (auth.LoginInput.password input) then
        session = auth.Auth.createSession user now
        Right session
      else Left auth.LoginFailure.InvalidPassword

auth.AuthService.signup :
  auth.SignupInput ->
  Instant ->
  {{openBrace}}auth.Auth, Random} Either auth.SignupFailure auth.Session
auth.AuthService.signup input now =
  use Nat <
  use Optional None Some
  use Text ++

  email = auth.SignupInput.email input
  password = auth.SignupInput.password input
  preferredName = auth.SignupInput.preferredName input

  match auth.Auth.getUserByEmail email with
    Some _ -> Left auth.SignupFailure.UserAlreadyExists
    None ->
      if Boolean.not (Text.contains "@" email) then
        Left auth.SignupFailure.InvalidEmail
      else if Text.size password < {{minPasswordLength}} then
        Left (auth.SignupFailure.InvalidPassword "Password must be at least {{minPasswordLength}} characters long")
      else
        hashedPassword = auth.Auth.hashPassword password
        userId = newv4() |> Uuid.toText
        newUser = auth.User.User userId preferredName email hashedPassword
        auth.Auth.upsertUser newUser
        session = auth.Auth.createSession newUser now
        Right session

auth.AuthService.getSessionFromCookie :
  Instant ->
  {{openBrace}}Route, auth.Auth} Optional auth.Session
auth.AuthService.getSessionFromCookie now =
  use Optional None
  match getCookie "{{cookieName}}" with
    None -> None
    Some token -> auth.Auth.getActiveSessionByToken token now

auth.AuthService.setSessionCookie :
  auth.Session ->
  {{openBrace}}Route} ()
auth.AuthService.setSessionCookie session =
  sessionCookie = cookie "{{cookieName}}" (auth.Session.token session)
  setCookie sessionCookie

-- =============================================================================
-- AUTH MIDDLEWARE
-- =============================================================================

auth.middleware.requireLogin :
  '{{openBrace}}g, Route, auth.Auth, Log} () ->
  {{openBrace}}g, Route, Exception, auth.Auth, Remote, Log} ()
auth.middleware.requireLogin protectedRoute =
  use Path /
  now = Remote.now()
  isLoggedIn = auth.AuthService.getSessionFromCookie now |> isSome
  if isLoggedIn then protectedRoute()
  else
    setStatus (Status 303 "See Other")
    headers.add "Location" (baseUrl() / "login" |> Path.toText)

-- =============================================================================
-- AUTH PAGES
-- =============================================================================

auth.pages.loginForm :
  Optional auth.LoginFailure ->
  '{{openBrace}}Route} Html
auth.pages.loginForm failure = do
  use {{htmlLib}} a article br button form h1 header input label p section text
  use Path /

  actionUrl = baseUrl() / "login" |> Path.toText
  signupUrl = baseUrl() / "signup" |> Path.toText

  article []
    [ header [] [h1 [] [text "Log In"]]
    , section []
        [ match failure with
            Optional.None -> {{htmlLib}}.empty
            Some auth.LoginFailure.UserNotFound ->
              p [Attribute "role" "alert"] [text "No account found with that email address."]
            Some auth.LoginFailure.InvalidPassword ->
              p [Attribute "role" "alert"] [text "Incorrect password. Please try again."]
        , form [Attribute.method "post", action actionUrl]
            [ label [for "email"]
                [ text "Email"
                , input
                    [ type_ "email"
                    , Attribute.name "email"
                    , id "email"
                    , required true
                    , placeholder "you@example.com"
                    , Attribute "autocomplete" "email"
                    ]
                ]
            , label [for "password"]
                [ text "Password"
                , input
                    [ type_ "password"
                    , Attribute.name "password"
                    , id "password"
                    , required true
                    , placeholder "Enter your password"
                    , Attribute "autocomplete" "current-password"
                    ]
                ]
            , button [type_ "submit"] [text "Log In"]
            ]
        , p []
            [ text "Don't have an account? "
            , a [href signupUrl] [text "Sign up here"]
            ]
        ]
    ]

auth.pages.signupForm :
  Optional auth.SignupFailure ->
  '{{openBrace}}Route} Html
auth.pages.signupForm failure = do
  use {{htmlLib}} a article br button form h1 header input label p section text
  use Path /

  actionUrl = baseUrl() / "signup" |> Path.toText
  loginUrl = baseUrl() / "login" |> Path.toText

  article []
    [ header [] [h1 [] [text "Sign Up"]]
    , section []
        [ match failure with
            Optional.None -> {{htmlLib}}.empty
            Some auth.SignupFailure.UserAlreadyExists ->
              p [Attribute "role" "alert"] [text "An account with that email already exists."]
            Some auth.SignupFailure.InvalidEmail ->
              p [Attribute "role" "alert"] [text "Please enter a valid email address."]
            Some (auth.SignupFailure.InvalidPassword msg) ->
              p [Attribute "role" "alert"] [text msg]
        , form [Attribute.method "post", action actionUrl]
            [ label [for "preferredName"]
                [ text "Preferred Name"
                , input
                    [ type_ "text"
                    , Attribute.name "preferredName"
                    , id "preferredName"
                    , required true
                    , placeholder "Your name"
                    , Attribute "autocomplete" "nickname"
                    ]
                ]
            , label [for "email"]
                [ text "Email"
                , input
                    [ type_ "email"
                    , Attribute.name "email"
                    , id "email"
                    , required true
                    , placeholder "you@example.com"
                    , Attribute "autocomplete" "email"
                    ]
                ]
            , label [for "password"]
                [ text "Password"
                , input
                    [ type_ "password"
                    , Attribute.name "password"
                    , id "password"
                    , required true
                    , placeholder "At least {{minPasswordLength}} characters"
                    , Attribute "autocomplete" "new-password"
                    ]
                ]
            , button [type_ "submit"] [text "Sign Up"]
            ]
        , p []
            [ text "Already have an account? "
            , a [href loginUrl] [text "Log in here"]
            ]
        ]
    ]

-- =============================================================================
-- REDIRECT HELPER
-- =============================================================================

auth.redirect : Path ->{{openBrace}}Route} ()
auth.redirect path =
  setStatus (Status 303 "See Other")
  headers.add "Location" (Path.toText path)

-- =============================================================================
-- AUTH ROUTES
-- =============================================================================

auth.routes :
  (Html ->{{openBrace}}Route, Exception} Html) ->
  '{{openBrace}}Route, Exception, auth.Auth, Remote, Random, Log} ()
auth.routes renderPage =
  use Route <|>
  use {{htmlLib}} toText

  getLogin = do
    noCapture GET (Parser.s "login")
    html = renderPage (auth.pages.loginForm Optional.None ())
    ok.html (toText html)

  postLogin = do
    noCapture POST (Parser.s "login")
    formData = getFormData()
    email = form.getOnly! "email" formData
    password = form.getOnly! "password" formData
    input = LoginInput email password
    result = auth.AuthService.login input Remote.now()
    match result with
      Left failure ->
        html = renderPage (auth.pages.loginForm (Some failure) ())
        badRequest.html (toText html)
      Right session ->
        auth.AuthService.setSessionCookie session
        auth.redirect baseUrl()

  getSignup = do
    noCapture GET (Parser.s "signup")
    html = renderPage (auth.pages.signupForm Optional.None ())
    ok.html (toText html)

  postSignup = do
    noCapture POST (Parser.s "signup")
    formData = getFormData()
    preferredName = form.getOnly! "preferredName" formData
    email = form.getOnly! "email" formData
    password = form.getOnly! "password" formData
    input = SignupInput preferredName email password
    result = auth.AuthService.signup input Remote.now()
    match result with
      Left failure ->
        html = renderPage (auth.pages.signupForm (Some failure) ())
        badRequest.html (toText html)
      Right session ->
        auth.AuthService.setSessionCookie session
        auth.redirect baseUrl()

  getLogin <|> postLogin <|> getSignup <|> postSignup
